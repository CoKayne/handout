<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>fft</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="./reveal.js/css/reset.css">
  <link rel="stylesheet" href="./reveal.js/css/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="./reveal.js/css/theme/black.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? './reveal.js/css/print/pdf.css' : './reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="./reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">


<section id="快速傅立葉變換" class="slide level1">
<h1>快速傅立葉變換</h1>
<p>相信不少人和我一樣,第一次看到傅里葉變換是在算法書上實現快速高精度乘法的章節,可是又看也看不懂,百度之後更加雲裡霧裡.</p>
<p>今天,我要試圖用簡單但不一定正確的理解,探討快速傅里葉變換(FFT)和高精度乘法之間的關係.</p>
</section>
<section id="傅里葉級數" class="slide level1">
<h1>傅里葉級數:</h1>
<p>在討論FFT之間,我們要說清楚一下各種傅里葉變換.</p>
<p>傅里葉變換最早要追朔到傅里葉級數 ,傅里葉級數其實和冪級數是同一個玩意.</p>
<p>冪級數是說,我使用x<sup>0</sup>,x<sup>1</sup>,x<sup>2</sup>,x<sup>3</sup>….加上不同的係數,可以表達世界上任何一個函數(誇張手法).</p>
<p>而傅里葉級數則說,我使用sin(0x),cos(0x),sin(x),cos(x),sin(2x),cos(2x),sin(3x),cos(3x)…..加上不同的係數,可以表達世界上任何一個週期函數(甚至非週期) .</p>
<p>於是乎,傅里葉級數的係數,和某個週期函數式,形成了對應關係.</p>
<p>我知道傅里葉級數的所有係數,就能求出對應的函數式.</p>
<p>我知道某個函數式,我可以求出傅里葉級數的所有係數.</p>
<p>這是高等數學上學到的.</p>
</section>
<section id="離散傅里葉變換" class="slide level1">
<h1>離散傅里葉變換:</h1>
<p>什麼是離散傅里葉變換(DFT)?我用一個非常簡單的例子來說明.</p>
<p>問題1: 已知y=f(x)=2+3x+x<sup>2</sup>,求x=0,1,2時y的值. 問題2: 已知一個二次函數f(x)經過點(0,2),(1,6),(2,12),求f(x)的函數表達式.</p>
<p>相信這兩個題目,99%的人都會做.但是,我們不是要做這兩個題目,而是要尋找它們的奧妙. 在問題1,我們知道f(x)的三個係數,求不同的x時y的值. 而問題2則反過來,我們知道三個不同的x時y的值,反過來求係數. 顯然f(x)=2+3x+x^2和二次函數f(x)經過(0,2),(1,6)(2,12),是在表達同一個函數,只是用了不同的形式 ! 沒錯,離散傅里葉變換就是這樣的,函數式和傅里葉係數是周期函數的兩種不同表達形式! 而這裡,多項式係數和點坐標是多項式函數的兩種不同表達形式. 我們知道多項式係數,可以求點坐標.我們知道點坐標,可以反過來求多項式係數.我們稱這種變換為離散傅里葉變換 .</p>
<p>有一點要注意的是,要想通過點坐標求出所有係數是有要求的. 如果是一個二次函數,它有3個係數,那麼我們需要三個點坐標的信息,並且這3個點不能重合,即x坐標不能一樣. 推廣的話,n次函數,有n+1個係數,需要n+1個點的信息. 這在線性代數里能得到有關的敘述和嚴格的證明.</p>
</section>
<section id="時域和頻域" class="slide level1">
<h1>時域和頻域:</h1>
<p>傅里葉變換有兩個很重要的術語,時域和頻域.</p>
<p>其實,在DFT裡,簡單地說,時域就是點坐標,頻域就是係數.</p>
<p>這麼說好像不容易理解,畢竟時域和頻域是在信號與系統那方面命名的,用在這裡有點奇怪.</p>
<p>不過,我們就這樣記住好了.時域是點坐標,頻域是係數.</p>
<p>要想理解時域和頻域的命名含義,可以看有關傅里葉變換的書籍.</p>
</section>
<section id="快速傅里葉變換" class="slide level1">
<h1>快速傅里葉變換:</h1>
<p>快速傅里葉變換FFT又是什麼呢?我們先看離散傅里葉變換DFT.</p>
<p>既然說FFT是個算法,談到算法我們當然要談時間複雜度.要實現DFT,時間複雜度是很高的.</p>
<p>比如從頻域到時域(知道係數,給出不同的x坐標,求y坐標),我們有O(n)個坐標要算,每個坐標是O(n)個項,複雜度就是O(n<sup>2</sup>)了.</p>
<p>反過來,從時域到頻域(知道坐標,求係數),我們要解一個n元一次方程組.用線性代數的高斯消元法,複雜度是O(n<sup>3</sup>).</p>
<p>那麼,FFT就是來降低這個複雜度的,它能把DFT的這兩個轉換的複雜度降到O(nlogn).</p>
</section>
<section id="多項式乘法與高精度乘法" class="slide level1">
<h1>多項式乘法與高精度乘法:</h1>
<p>本文的第二個主角,高精度乘法終於出場了.</p>
<p>實現高精度乘法,其實和實現多項式乘法是幾乎一樣的.</p>
<p>這話怎說?其實,我們用某個進制去表達一個數字,恰恰和多項式的表達一模一樣.</p>
<p>比如15386,它其實是<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><msup><mn>10</mn><mn>4</mn></msup><mo>+</mo><mn>5</mn><mo>×</mo><msup><mn>10</mn><mn>3</mn></msup><mo>+</mo><mn>3</mn><mo>×</mo><msup><mn>10</mn><mn>2</mn></msup><mo>+</mo><mn>8</mn><mo>×</mo><msup><mn>10</mn><mn>1</mn></msup><mo>+</mo><mn>6</mn><mo>×</mo><msup><mn>10</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">1\times 10^4+5\times 10^3+3\times 10^2+8\times 10^1+6\times 10^0</annotation></semantics></math>.</p>
<p>這和函數<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msup><mi>x</mi><mn>4</mn></msup><mo>+</mo><mn>5</mn><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>3</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>8</mn><msup><mi>x</mi><mn>1</mn></msup><mo>+</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">f(x)=x^4+5x^3+3x^2+8x^1+6</annotation></semantics></math>是一個套路.</p>
<p>那麼,兩個數字的乘法,其實就是兩個多項式的乘法.</p>
<p>例如<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>12</mn><mo>×</mo><mn>43</mn></mrow><annotation encoding="application/x-tex">12 \times 43</annotation></semantics></math>,我們可以理解為<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>+</mo><mn>2</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mn>4</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x+2)(4x+3)</annotation></semantics></math>.</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>+</mo><mn>2</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mn>4</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>4</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>11</mn><mi>x</mi><mo>+</mo><mn>6</mn><mo>,</mo><mi>所</mi><mi>以</mi><mn>12</mn><mo>×</mo><mn>43</mn><mo>=</mo><mn>4</mn><mo>×</mo><msup><mn>10</mn><mn>2</mn></msup><mo>+</mo><mn>11</mn><mo>×</mo><mn>10</mn><mo>+</mo><mn>6</mn><mi>.</mi></mrow><annotation encoding="application/x-tex">(x+2)(4x+3)=4x^2+11x+6,所以12\times 43=4\times 10^2+11\times10+6.</annotation></semantics></math></p>
<p>稍有不同的是,數字乘法要進位,所以(4,11,6)要變成(5,1,6),也就是<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>12</mn><mo>×</mo><mn>43</mn><mo>=</mo><mn>516</mn></mrow><annotation encoding="application/x-tex">12\times 43=516</annotation></semantics></math>.</p>
<p>好了,我們已經明白了多項式乘法和高精度乘法是蛇鼠一窩了.</p>
<p>接下來,我們看看多項式乘法的算法複雜度.分析很簡單,兩個for循環,<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math>.</p>
<p>而FFT告訴你,我能<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n logn)</annotation></semantics></math>幫你搞定!</p>
</section>
<section id="fft實現多項式乘法" class="slide level1">
<h1>FFT實現多項式乘法</h1>
<p>FFT如何實現多項式乘法,我們先探討多項式乘法的本質. 多項式乘法,其實就是給出你兩個多項式的頻域,求它們的積的頻域!</p>
<p>我們知道兩個多項式的表達式,其實就是知道頻域(係數),而我們要求的是它們的積的表達式,也就是求頻域.</p>
<p>我們把上面的結論收集起來,說明如何用FFT實現O(nlogn)多項式乘法.</p>
<p>1.FFT能O(nlogn)實現頻域到時域</p>
<p>2.FFT能O(nlong)實現時域到頻域</p>
<p>3.我們知道兩個多項式的頻域,要求它們的積的頻域.</p>
<p>只有這三個結論是不夠的,我們還需要一個很白痴但你可能想不到的結論: 4.我們知道兩個多項式的時域,能O(n)時間求出它們的積的時域.</p>
<p>這個結論看似很難,但講清楚之後你會發現很白痴.</p>
<p>知道兩個多項式的時域,就是知道了<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math>經過$(x1,f1),(x2,f2)…(xn,fn)</p>
<p>g(x)<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>經</mi><mi>過</mi></mrow><annotation encoding="application/x-tex">經過</annotation></semantics></math>(x1,g1),(x2, g2)….(xn,gn)$</p>
<p>設<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>*</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">k(x)=f(x)*g(x),</annotation></semantics></math>那麼<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">k(x)</annotation></semantics></math>在<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mn>1</mn><mo>,</mo><mi>x</mi><mn>2</mn><mi>.</mi><mi>.</mi><mi>.</mi><mi>x</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">x1,x2...xn</annotation></semantics></math>上的y坐標是多少?一想就知道是<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mn>1</mn><mo>*</mo><mi>g</mi><mn>1</mn><mo>,</mo><mi>f</mi><mn>2</mn><mo>*</mo><mi>g</mi><mn>2</mn><mi>.</mi><mi>.</mi><mi>.</mi><mi>.</mi><mi>f</mi><mi>n</mi><mo>*</mo><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">f1*g1,f2*g2.. ..fn*gn</annotation></semantics></math> 因為<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mi>i</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mi>i</mi><mo stretchy="false" form="postfix">)</mo><mo>*</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mi>i</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">k(xi)=f(xi)*g(xi)</annotation></semantics></math>啊!!</p>
<p>也就是說<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">k(x)</annotation></semantics></math>會經過<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mn>1</mn><mo>,</mo><mi>f</mi><mn>1</mn><mo>*</mo><mi>g</mi><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mn>2</mn><mo>,</mo><mi>f</mi><mn>2</mn><mo>*</mo><mi>g</mi><mn>2</mn><mo stretchy="false" form="postfix">)</mo><mi>.</mi><mi>.</mi><mi>.</mi><mi>.</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mi>n</mi><mo>,</mo><mi>f</mi><mi>n</mi><mo>*</mo><mi>g</mi><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x1,f1*g1),(x2,f2*g2)....(xn,fn*gn)</annotation></semantics></math>.這些點,就是<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">k(x)</annotation></semantics></math>的時域啊!</p>
<p>這裡的複雜度不用說都知道是<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math>,原來“時域相乘”是這麼簡單的事情,比“頻域相乘”簡單多了.</p>
<p>現在我們可以用FFT實現O(nlogn)多項式乘法了!</p>
<p>1.用FFT在O(nlogn)時間,把f(x)和g(x)的頻域轉變為時域</p>
<p>2.用O(n)時間,把f(x)和g(x)的時域變成k(x)的時域</p>
<p>3.用FFT在O(nlogn)時間,把k(x)的時域轉變為頻域</p>
</section>
<section id="fft算法" class="slide level1">
<h1>FFT算法</h1>
<p>前面我們說了一大堆,目的是說明為什麼FFT能實現nlogn多項式乘法. 現在,我們剩下的問題,也就是最核心的問題是,如何實現FFT算法?</p>
<p>FFT算法包括頻域到時域,以及時域到頻域.</p>
<p>我們在這裡著重討論頻域到時域,也就是上面那個圖的第一個箭頭.</p>
<p>現在我們知道的是兩個函數的頻域(n個多項式係數),我們要求它們的時域(n個點坐標).</p>
<p>還有一點是,這個n一定要是2的冪.如果不是,你可以強制改成是.</p>
<p>比如n=6,你可以加上0<em>n^7+0</em>n ^6,強行讓它有8個項.</p>
<p>首先有一個問題,如何選擇時域的一組x坐標呢?</p>
<p>我們知道,時域的n個點並不是確定的,它們只需要保證x坐標互不相同就能構成一個時域.</p>
<p>那麼,我們是不是可以隨便找n個x坐標就可以了呢?像x=1,2,3…n這樣,行嗎? 答案是不行!前文說道FFT轉換有一個限制,這個限制就在這裡:我們不能任意選擇x坐標!</p>
<p>你要得到x=1,2…對應的y坐標,抱歉,FFT告訴你我做不 ,你要求只能老老實實O(n2). 那麼,什麼樣的一組x坐標,FFT能O(nlogn)求出對應的y坐標呢? 答案是x^n=1這個方程的所有根.</p>
<p>下面所說的需要比較多的數學知識,請看不懂的同志自行百度惡補,這裡有一篇<a href="http://wenku.baidu.com/link?url=RWHc2uPEZWdbo0TTVM3z320hJidSR5hk-6YcYQbG6n9n2WzrDKcx1E4r_XS0ZtIqkLjgxODMq_Q8GlK-wGJgZCyHsd1aPhFjBC9Ute2yB0G">參考文章</a></p>
<p>哈?!這個方程的解不就只有1,如果n是偶數就是1和-1.我可是要n個x坐標喔!</p>
<p>注意了,我這裡是說x<sup>n</sup>=1的所有複數根,而不只是實數根.</p>
<p>可能有些同學複數學得少,在這裡就困惑了.x^n=1這方程一定有n個複數根嗎?</p>
<p>答案是一定的,一元n次方程有且只有n個複數根.這是代數基本定理.</p>
<p>並且,我還可以告訴你這n個複數根分別是什麼,使用複數開方公式就可以了.</p>
<p>對於一個複數z,我們使用其三角函數形式表達,z=r(cosθ+isinθ)</p>
<p>那麼z開n次方的所有根就是<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mroot><mi>r</mi><mi>n</mi></mroot><mo>×</mo><mo stretchy="false" form="prefix">(</mo><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false" form="prefix">(</mo><mfrac><mrow><mi>θ</mi><mo>+</mo><mn>2</mn><mi>k</mi><mi>π</mi></mrow><mi>n</mi></mfrac><mo>+</mo><mi>i</mi><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false" form="prefix">(</mo><mfrac><mrow><mi>θ</mi><mo>+</mo><mn>2</mn><mi>k</mi><mi>π</mi></mrow><mi>n</mi></mfrac><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">[</mo><mi>k</mi><mo>∈</mo><mi>Z</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\sqrt[n]{r} \times (cos(\frac{\theta + 2k \pi}{n}+isin (\frac{\theta + 2k \pi}{n})) [k∈Z]</annotation></semantics></math></p>
<p>啥?k∈Z,那這裡不就有無限個複數? 並不是哦,注意k是在cos和sin裡面的,是有周期的. 並且很容易知道,週期就是n,也就是說k=0和k=n的結果是一樣的. 就看式子可能還是很抽象,我們把這n個根畫在復平面上,就一目了然了. <img data-src="https://i.imgur.com/KDZy55d.png" /></p>
<p>這是算法導論上 圖片,它定義了一個符號.( 下面我使用<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>w</mi><mi>k</mi><mi>n</mi></msubsup><annotation encoding="application/x-tex">{w^n_k}</annotation></semantics></math>去表達這個符號 )</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>w</mi><mi>i</mi><mi>n</mi></msubsup><annotation encoding="application/x-tex">{w^n_i}</annotation></semantics></math>其實是表示<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x^n=1</annotation></semantics></math>這個方程的所有根中,令<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">k=i</annotation></semantics></math>的那一個(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>就是剛才那個式子的<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>)</p>
<p>事實上<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>w</mi><mi>k</mi><mi>n</mi></msubsup><annotation encoding="application/x-tex">{w^n_k}</annotation></semantics></math>的<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>是<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>次方的意思,而<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>w</mi><mi>n</mi></msup><annotation encoding="application/x-tex">w^n</annotation></semantics></math>則是<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>e</mi><mrow><mfrac><mrow><mn>2</mn><mi>π</mi><mi>i</mi></mrow><mi>n</mi></mfrac><mo stretchy="false" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">e^{\frac{2πi}{n})}</annotation></semantics></math>.</p>
<p>但這兩個定義是等價的,前者是我自己的理解,後者是算法導論上的定義.(詳情參考算法導論 )</p>
<p>在這裡,可以很清楚地看到<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>8</mn></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x^8=1</annotation></semantics></math>中真的有<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>8</mn><annotation encoding="application/x-tex">8</annotation></semantics></math>個複數根,並且那個週期真的是<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>8</mn><annotation encoding="application/x-tex">8</annotation></semantics></math>.</p>
<p>好,我們得到了n個x坐標,但是是複數的.</p>
<p>有人可能會問,這個x坐標是複數的,怎麼對應在xy平面上的某個點啊? 答案當然是不能對應,正確來說是不能在xy平面上對應.</p>
<p>這裡的x坐標和y坐標,其實已經是一個四維面上的兩條軸了,不能單單用xy平面去理解了.</p>
<p>不過,這裡FFT並不關心你是實數還是複數,它就是根據x坐標,算出y坐標而已.</p>
<p>那麼,FFT算法要怎麼<span class="math inline">$O(n \space logn)$</span>把這n個x坐標轉換成對應的y坐標呢? 答案是分治,FFT算法是一個分治的算法,分而治之.</p>
<p>那麼,兩個關鍵的問題就是,如何“分”?如何“治”?</p>
<p>考慮如何分,就要先說清楚原問題和子問題是什麼,我們現在說清楚.</p>
<p>FFT算法,是已知 個n-1次的多項式函數,求出n個x坐標對應的y坐標,這n個x坐標是x^n=1的n個複數根.(注意是n-1次,不是n次,因為n-1次多項式有n項)</p>
<p>舉個例子,現在我有一個(8-1)次的多項式,我要求出x^8=1的8個根作為x坐標,對應的y坐標.</p>
<p>那麼子問題是,我有一個(4-1)次的多項式,我要求出x^4=1的4個根作為x坐標,對應的y坐標.</p>
<p>那麼,如何從原問題轉變成子問題? 首先,我們需要幾個挺容易理解的公式.</p>
<h3 id="wn_k2wfracn2_k"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msubsup><mi>w</mi><mi>k</mi><mi>n</mi></msubsup><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">({w^{n}_k})^2</annotation></semantics></math>=<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>w</mi><mi>k</mi><mfrac><mi>n</mi><mn>2</mn></mfrac></msubsup><annotation encoding="application/x-tex">w^{\frac{n}{2}}_k</annotation></semantics></math></h3>
<h3 id="wdn_dkwn_k"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>w</mi><mrow><mi>d</mi><mi>k</mi></mrow><mrow><mi>d</mi><mi>n</mi></mrow></msubsup><annotation encoding="application/x-tex">{w^{dn}_{dk}}</annotation></semantics></math>=<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>w</mi><mi>k</mi><mi>n</mi></msubsup><annotation encoding="application/x-tex">{w^n_k}</annotation></semantics></math></h3>
<h3 id="wn_nkwn_k"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>w</mi><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow><mi>n</mi></msubsup><annotation encoding="application/x-tex">{w^n_{n+k}}</annotation></semantics></math>=<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>w</mi><mi>k</mi><mi>n</mi></msubsup><annotation encoding="application/x-tex">{w^n_k}</annotation></semantics></math></h3>
<h3 id="wn_-kfrac1wn_k"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>w</mi><mrow><mo>−</mo><mi>k</mi></mrow><mi>n</mi></msubsup><annotation encoding="application/x-tex">{w^n_{-k}}</annotation></semantics></math>=<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><msubsup><mi>w</mi><mi>k</mi><mi>n</mi></msubsup></mfrac><annotation encoding="application/x-tex">{\frac{1}{{w^n_k}}}</annotation></semantics></math></h3>
<p>現在,以<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">n=4</annotation></semantics></math>為例子,<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msub><mi>a</mi><mn>3</mn></msub><msup><mi>x</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">y=a_0+a_1x+a_2x^2+a_3x^3</annotation></semantics></math> 我們的問題是,要求出<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>4</mn></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x^4=1</annotation></semantics></math>的4個根作為<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>坐標,對應的<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>坐標. 我們按照x的指數的奇偶性,把<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>分成兩部分<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>a</mi></msub><annotation encoding="application/x-tex">y_a</annotation></semantics></math>和<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>b</mi></msub><annotation encoding="application/x-tex">y_b</annotation></semantics></math>. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>a</mi></msub><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">y_a=a_0+a_2x^2</annotation></semantics></math> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>b</mi></msub><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><msub><mi>a</mi><mn>3</mn></msub><msup><mi>x</mi><mn>3</mn></msup><mo>=</mo><mi>x</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>3</mn></msub><msup><mi>x</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">y_b=a_1x+a_3x^3=x(a_1+a_3x^2)</annotation></semantics></math> 然後我們定義y1,y2 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><mi>x</mi></mrow><annotation encoding="application/x-tex">y_1=a_0+a_2x</annotation></semantics></math> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mn>2</mn></msub><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>3</mn></msub><mi>x</mi></mrow><annotation encoding="application/x-tex">y_2=a_1+a_3x</annotation></semantics></math></p>
<p>然後,我們得到了子問題,我們已知<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mn>1</mn></msub><annotation encoding="application/x-tex">y_1</annotation></semantics></math>和<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mn>2</mn></msub><annotation encoding="application/x-tex">y_2</annotation></semantics></math>這兩個(2-1)次函數</p>
<p>我要求出<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x^2=1</annotation></semantics></math>的2個根作為x坐標,對應的<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mn>1</mn></msub><annotation encoding="application/x-tex">y_1</annotation></semantics></math>和<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mn>2</mn></msub><annotation encoding="application/x-tex">y_2</annotation></semantics></math></p>
<p>為什麼這樣就是子問題了,或者說為什麼要選這樣的y1和y2作為子問題的多項式? 因為首先它符合子問題的要求,其次是我們有了這兩個子問題的答案,能給出原問題的答案</p>
<p>也就是,它能幫我們實現分而治之的“治”</p>
<p>怎麼治? 我們從子問題得到的答案是<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msubsup><mi>w</mi><mn>0</mn><mn>2</mn></msubsup><mo stretchy="false" form="postfix">)</mo><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msubsup><mi>w</mi><mn>1</mn><mn>2</mn></msubsup><mo stretchy="false" form="postfix">)</mo><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false" form="prefix">(</mo><msubsup><mi>w</mi><mn>0</mn><mn>2</mn></msubsup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">y_1({w^2_0}),y_1({w^2_1}),y_2({w^2_0})</annotation></semantics></math>和<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false" form="prefix">(</mo><msubsup><mi>w</mi><mn>1</mn><mn>2</mn></msubsup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">y_2({w^2_1})</annotation></semantics></math> 而我們要求的答案是<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo stretchy="false" form="prefix">(</mo><msubsup><mi>w</mi><mn>0</mn><mn>4</mn></msubsup><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>y</mi><mo stretchy="false" form="prefix">(</mo><msubsup><mi>w</mi><mn>1</mn><mn>4</mn></msubsup><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>y</mi><mo stretchy="false" form="prefix">(</mo><msubsup><mi>w</mi><mn>2</mn><mn>4</mn></msubsup><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>y</mi><mo stretchy="false" form="prefix">(</mo><msubsup><mi>w</mi><mn>3</mn><mn>4</mn></msubsup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">y({w^4_0}),y({w^4_1}),y({w^4_2}),y({w^4_3})</annotation></semantics></math></p>
<p>在這裡,上面的幾條公式就有用了</p>
<p>我們看y和y1y2的關係</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msup><mi>x</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mi>x</mi><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false" form="prefix">(</mo><msup><mi>x</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">y(x)=y_1(x^2)+xy_2(x^2)</annotation></semantics></math></p>
<p>那麼,我們把<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>w</mi><mn>0</mn><mn>4</mn></msubsup><annotation encoding="application/x-tex">{w^4_0}</annotation></semantics></math>代入x裡,得到: <span class="math inline">$y({w^4_0})=y_1 ({w^4_0}^2)+{w^4_k}\space y_2({w^4_0}^2)$</span></p>
<p>根據公式1,<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msubsup><mi>w</mi><mn>0</mn><mn>4</mn></msubsup><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mo>=</mo><msubsup><mi>w</mi><mn>0</mn><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">({w^4_0})^2={w^2_0}</annotation></semantics></math>,所以: <span class="math inline">$y({w^4_0})=y1\space ({w^0_2})+{w^4_k}\space y_2({w^2_0})$</span></p>
<p>我們也代入<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>w</mi><mn>1</mn><mn>4</mn></msubsup><annotation encoding="application/x-tex">{w^4_1}</annotation></semantics></math> 得到: <span class="math inline">$y({w^4_1})=y_1\space ({w^1_2})+{w^4_0}\space y_2({w^2_1})$</span></p>
<p>那<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>w</mi><mn>2</mn><mn>4</mn></msubsup><annotation encoding="application/x-tex">{w^4_2}</annotation></semantics></math>呢? <span class="math inline">$y({w^4_2})=y_1\space ({w^2_2})+{w^4_1}\space y_2({w^2_2})$</span></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>w</mi><mn>2</mn><mn>2</mn></msubsup><annotation encoding="application/x-tex">{w^2_2}</annotation></semantics></math>是啥,根據公式三的周期性質,<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>w</mi><mn>0</mn><mn>2</mn></msubsup><annotation encoding="application/x-tex">{w^2_0}</annotation></semantics></math>=<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>w</mi><mn>2</mn><mn>2</mn></msubsup><annotation encoding="application/x-tex">{w^2_2}</annotation></semantics></math>,所以: <span class="math inline">$y({w_2^4})=y_1\space ({w^0_2})+{w^4_2} \space y_2({w^2_0})$</span></p>
<p>同樣道理寫出<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>w</mi><mn>4</mn><mn>3</mn></msubsup><annotation encoding="application/x-tex">{w^3_4}</annotation></semantics></math>: <span class="math inline">$y({w^4_3})=y_1\space ({w^1_2})+{w^4_3} \space y_2({w^2_1})$</span></p>
<p>寫在一起就是: <span class="math inline">$y({w^4_0})=y_1\space({w^2_0})+{w^4_0}\space y_2({w^2_0})$</span></p>
<p><span class="math inline">$y({w^4_1})=y_1\space({w^2_1})+{w^4_1}\space y_2({w^2_1})$</span></p>
<p><span class="math inline">$y({w^4_3})=y_1\space({w^2_0})+{w^4_2}\space y_2({w^2_0})$</span></p>
<p><span class="math inline">$y({w^4_4})=y_1\space({w^2_1})+{w^4_3}\space y_2({w^2_1})$</span></p>
<p>有沒有發現,求<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo stretchy="false" form="prefix">(</mo><msubsup><mi>w</mi><mn>0</mn><mn>4</mn></msubsup><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>y</mi><mo stretchy="false" form="prefix">(</mo><msubsup><mi>w</mi><mn>1</mn><mn>4</mn></msubsup><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>y</mi><mo stretchy="false" form="prefix">(</mo><msubsup><mi>w</mi><mn>2</mn><mn>4</mn></msubsup><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>y</mi><mo stretchy="false" form="prefix">(</mo><msubsup><mi>w</mi><mn>3</mn><mn>4</mn></msubsup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">y({w^4_0}),y({w^4_1}),y({w^4_2}),y({w^4_3})</annotation></semantics></math>的式子中,除了<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>w</mi><mn>0</mn><mn>4</mn></msubsup><mo>,</mo><msubsup><mi>w</mi><mn>1</mn><mn>4</mn></msubsup><mo>,</mo><msubsup><mi>w</mi><mn>2</mn><mn>4</mn></msubsup><mo>,</mo><msubsup><mi>w</mi><mn>3</mn><mn>4</mn></msubsup></mrow><annotation encoding="application/x-tex">{w^4_0},{w^4_1},{w^4_2},{w^4_3}</annotation></semantics></math>其他項都是子問題返回的答案,<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>w</mi><mn>0</mn><mn>4</mn></msubsup><mo>,</mo><msubsup><mi>w</mi><mn>1</mn><mn>4</mn></msubsup><mo>,</mo><msubsup><mi>w</mi><mn>2</mn><mn>4</mn></msubsup><mo>,</mo><msubsup><mi>w</mi><mn>3</mn><mn>4</mn></msubsup></mrow><annotation encoding="application/x-tex">{w^4_0},{w^4_1},{w^4_2},{w^4_3}</annotation></semantics></math></p>
<p>那剩下的問題是怎麼求<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>w</mi><mn>0</mn><mn>4</mn></msubsup><mo>,</mo><msubsup><mi>w</mi><mn>1</mn><mn>4</mn></msubsup><mo>,</mo><msubsup><mi>w</mi><mn>2</mn><mn>4</mn></msubsup><mo>,</mo><msubsup><mi>w</mi><mn>3</mn><mn>4</mn></msubsup></mrow><annotation encoding="application/x-tex">{w^4_0},{w^4_1},{w^4_2},{w^4_3}</annotation></semantics></math></p>
<p>剛開始,我以為這些根是用某種特殊形式表現的</p>
<p>結果發現,它就直接用浮點複數表現了! 也就是說,即使你想實現整數多項式相乘,使用FFT得到的結果是一個浮點數多項式,你需要四捨五入去得到正確的整數!</p>
<p>那<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>w</mi><mn>0</mn><mn>4</mn></msubsup><mo>,</mo><msubsup><mi>w</mi><mn>1</mn><mn>4</mn></msubsup><mo>,</mo><msubsup><mi>w</mi><mn>2</mn><mn>4</mn></msubsup><mo>,</mo><msubsup><mi>w</mi><mn>3</mn><mn>4</mn></msubsup></mrow><annotation encoding="application/x-tex">{w^4_0},{w^4_1},{w^4_2},{w^4_3}</annotation></semantics></math>到底怎麼求?你可以直接用開方的那個式子! 那式子中要開方的複數是1,所以<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>θ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">r=1,θ=0</annotation></semantics></math>即可 因此: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><msubsup><mi></mi><mi>k</mi><mi>n</mi></msubsup><mo>=</mo><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false" form="prefix">(</mo><mfrac><mrow><mn>2</mn><mi>k</mi><mi>π</mi></mrow><mi>n</mi></mfrac><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mi>i</mi><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false" form="prefix">(</mo><mfrac><mrow><mn>2</mn><mi>k</mi><mi>π</mi></mrow><mi>n</mi></mfrac><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">w{^n_k}=cos(\frac{2kπ}{n})+isin(\frac{2kπ}{n})</annotation></semantics></math> 將k和n都代進去算的話就得到: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>w</mi><mn>0</mn><mn>4</mn></msubsup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">{w^4_0}=1</annotation></semantics></math> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>w</mi><mn>1</mn><mn>4</mn></msubsup><mo>=</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">{w^4_1}=i</annotation></semantics></math> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>w</mi><mn>2</mn><mn>4</mn></msubsup><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">{w^4_2}=-1</annotation></semantics></math> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>w</mi><mn>3</mn><mn>4</mn></msubsup><mo>=</mo><mo>−</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">{w^4_3}=-i</annotation></semantics></math> 這裡<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">n=4</annotation></semantics></math>的情況下,這些複數的實部和虛部都是整數</p>
<p>但從<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>8</mn><annotation encoding="application/x-tex">8</annotation></semantics></math>開始就不是整數的了,甚至大部分都是無理數,因此只能用浮點數去表示</p>
<p>還有一個小問題是遞歸的終點,終點就是n=1的時候</p>
<p>這個時候,我們要求的是<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>w</mi><mn>0</mn><mn>1</mn></msubsup><mi>其</mi><mi>實</mi><mi>就</mi><mi>是</mi><mn>1</mn><mi>作</mi><mi>為</mi><mi>x</mi><mi>坐</mi><mi>標</mi><mo>,</mo><mi>對</mi><mi>應</mi><mi>的</mi><mi>y</mi><mi>坐</mi><mi>標</mi></mrow><annotation encoding="application/x-tex">{w^1_0}其實就是1作為x坐標,對應的y坐標</annotation></semantics></math> 在這裡我們的多項式只有一項,也就是只有常數,因此我們返回這個常數就行</p>
<p>到這 ,我們真的實現了從頻域到時域的轉換</p>
<p>不難知道這個算法複雜度是O(nlogn)</p>
<p>(f(n)=2*f(n/2)+O(n),和歸併排序類似)</p>
<p>我們用python去實現一下,這個優美的FFT算法</p>
<p>代碼:</p>
<p>運行結果:</p>
<p>代碼解釋: 多項式我們使用列表來儲存,從前到後分別是0次項,1次項,2次項… 子問題返回的n個y坐標也是用列表儲存,從前到後分別是y0,y1,y2. ..</p>
<p>python中復數能直接表示和運算,無需特殊的類. 並且,虛數i在python中用j表示.</p>
<p>第6,7行是遞歸終點的特殊處理. 第9到13行是構建y1和y2. 第15,16行是遞歸調用,得到子問題答案. 第19行到第23行是計算並返回原問題答案. 第20行和第21行的計算公式看起來比較複雜,但根據前文推導就發現也不是太難.</p>
<p>我們的樣例是<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>2</mn><mo>+</mo><mn>3</mn><mi>x</mi><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><msup><mi>x</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">f(x)=2+3x+x^2+2x^3</annotation></semantics></math>,也就是頻域是<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[2,3,1,2]</annotation></semantics></math> 從運行結果可以看到,FFT得到的時域是一堆浮點數. 我們整理後得到的時域是<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>8</mn><mo>,</mo><mn>1</mn><mo>+</mo><mi>i</mi><mo>,</mo><mo>−</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo>−</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[8,1+i,-2,1-i]</annotation></semantics></math> 如果你將x^4=1的四個根<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>,</mo><mi>i</mi><mo>,</mo><mo>−</mo><mn>1</mn><mo>,</mo><mo>−</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">1,i,-1, -i</annotation></semantics></math>代入多項式,得到的結果也就是這四個值. 這說明,算法正確!</p>
<p>我們已經能實現從頻域到時域了,那我們要怎麼做才能實現時域到頻域? 數學家發現,從頻域到時域和從時域到頻域的實現幾乎一樣! 這 使用線性代數的知識去解釋.</p>
<p>從頻域到時域,其實就是頻域的n個係數組成一個列,然後乘一個<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \times n</annotation></semantics></math>矩陣,得到另一個列,而這個列就是y坐標組成的列.如下圖(出自算法導論 ):</p>
<p>為什麼中間的<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n\times n</annotation></semantics></math>矩陣是這個樣子?你用矩陣乘法算一算某個行乘列a就懂了,這其實就是把w[k,n]代進了多項式後的式子. 為什麼我們要把從頻域到時域理解成矩陣乘法呢?因為矩陣乘法有一個特殊的性質. 如果y=M<em>a,矩陣M是可逆的,那麼a=M^(-1)</em>y. 它的意思就是,如果M是可逆矩陣,那麼我們拿M的逆去乘時域y,就能得到頻域a. 也就是,它能實現從時域到頻域.</p>
<p>那M可逆嗎?這個矩陣其實是有名字的,叫范德蒙矩陣 . 嗯,在線性代數里可以證明,它是可逆的.也就是說,有戲! 那M的逆是什麼呢?這個線性代數也幫我們算好了,如下圖:</p>
<p>有了逆矩陣有什麼用呢?矩陣乘法複雜度可是O(n3)的. 誰說用矩陣乘法了?我們還是用FFT. 我們把得到的時域y理解為新的一組係數,把要求的頻域a理解為新的一組y坐標,然後新選取的一組x坐標是w[-1,n],w[-2,n]… 你就會發現,這樣FFT轉換的含義剛好和這個矩陣乘法式子吻合.並且選取的這組x坐標,也能像剛才那組一樣分而治之(你可以像上面一樣試一下.) 也就是說,我們可以依樣畫葫蘆,使 FFT實現從時域到頻域,只是選取的x坐標換了,並且最後得到的結果要除以一個n. w[-1,n],w[-2,n]怎麼求…公式四w[-k,n]=1/w[k,n],完.</p>
<p>代碼:</p>
<p>運行結果:</p>
<p>代碼解釋: 我們在原來的FFT函數里加上inverse參數,inverse為true的話,表示我們的FFT要實現從時域到頻域. 然後在第21行加上一句,如果inverse為true則w=1/w,即現在的w表示w[-i,n]而不是w[i,n].</p>
<p>樣例還是使用原來的,我們先將頻域轉為時域得到y,再從時域轉為頻域得到new_fx. 由於FFT函數里沒有幫我們將結果除以n,所以我們在第30行自己實現了.</p>
<p>整理一下運行結果後可以看到,new_fx=[2,3,1,2]. 也就是說,new_fx= fx!我們的FFT轉換是對的! 我們實現了從頻域到時域,也實現了從時域到頻域.</p>
</section>
<section id="fft算法實現多項式乘法" class="slide level1">
<h1>FFT算法實現多項式乘法:</h1>
<p>最後我們來用FFT算法實現多項式乘法,在這裡我們要特殊處理一些東西. 一個是多項式的長度,不是2<sup>k要變成2</sup>k. 另一個是積的時域的問題,假如兩個要乘的多項式都是有n項,我們在FFT轉換後得到n個點. 這n個點的y坐標相乘得到目標多項式的n個點,但是目標多項式理論上最多是有2n-1項的(如果是整數乘法則可以有2n位). 所以,這n個點會造成信息的丟失,它並不能構成目標的時域. 怎麼辦?我們一開始求2n個點就好了! 也就是把要乘的那兩個多項式的長度增長到2n,增長的部分的係數全部填0,OK~! 那假如兩個要乘的多項式的項數不一樣呢?簡單,把短的拉成和長的一樣. (PS:這裡的項數的意思其實是最高次數+1,例如x^2+1我們要說成3項.)</p>
<p>代碼:</p>
<p>運行結果:</p>
<p>代碼解釋: 上圖代碼調用的fft函數就是前一份代碼裡的fft函數. 代碼裡的27行到34行,都是在處理長度問題,包括長度統一,找符合條件的最小的2的冪,以及擴大兩倍. 36,37行是第一個箭頭,實現頻域到時域. 39行則是第二個箭頭,求出目標多項式的時域. 41,42行是第三個箭頭,實現時域到頻域.</p>
<p>我們用<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mn>3</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mo stretchy="false" form="prefix">(</mo><mn>5</mn><mi>x</mi><mo>+</mo><mn>4</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(3x^2+2x+1)\times(5x+4)</annotation></semantics></math>作為樣例,手算一下答案是<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>15</mn><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>13</mn><mi>x</mi><mo>+</mo><mn>22</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>4</mn><mi>.</mi></mrow><annotation encoding="application/x-tex">15x^3+13x+22x^2+4.</annotation></semantics></math> 那運行結果呢,一堆很難看的浮點數. 我們整理一下,得出結果就是<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>15</mn><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>13</mn><mi>x</mi><mo>+</mo><mn>22</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">15x^3+13x+22x^2+4</annotation></semantics></math> 雖然結果有8項,但很容易發現後面4項都是0.</p>
<p>FFT實現多項式乘法,在實際的操作上有許多種版本,我這裡只是其中的一種,並且是效率不高的一種. 但是,只要思路掌握了,無論什麼樣的版本都是一個套路.</p>
</section>
<section id="c程式碼" class="slide level1">
<h1>C++程式碼</h1>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#include</span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="pp">#define rep</span>(i,n)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=<span class="dv">0</span>;i&lt;((<span class="dt">int</span>)n);i++)</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="pp">#define IOS </span>ios_base::sync_with_stdio(<span class="dv">0</span>);<span class="pp"> </span>cin.tie(<span class="dv">0</span>)</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="pp">#define endl </span><span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="pp">#define SZ</span>(n)<span class="pp"> </span>((<span class="dt">int</span>)n.size())</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="at">const</span> <span class="dt">int</span> N=<span class="dv">2000010</span>;</span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="at">const</span> <span class="dt">double</span> pi=acos(-<span class="fl">1.0</span>);</span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="kw">struct</span> node{</span>
<span id="cb1-11"><a href="#cb1-11"></a>    <span class="dt">double</span> x,y;</span>
<span id="cb1-12"><a href="#cb1-12"></a>    node (<span class="dt">double</span> xx=<span class="dv">0</span>,<span class="dt">double</span> yy=<span class="dv">0</span>){</span>
<span id="cb1-13"><a href="#cb1-13"></a>        x=xx;y=yy;</span>
<span id="cb1-14"><a href="#cb1-14"></a>    }</span>
<span id="cb1-15"><a href="#cb1-15"></a>};</span>
<span id="cb1-16"><a href="#cb1-16"></a>node a[N],b[N],omega[N],a_omega[N];</span>
<span id="cb1-17"><a href="#cb1-17"></a><span class="dt">int</span> n,m,fn,num[N];</span>
<span id="cb1-18"><a href="#cb1-18"></a>string c;</span>
<span id="cb1-19"><a href="#cb1-19"></a></span>
<span id="cb1-20"><a href="#cb1-20"></a>node <span class="kw">operator</span> +(<span class="at">const</span> node &amp;a,<span class="at">const</span> node &amp;b){<span class="cf">return</span> node (a.x+b.x,a.y+b.y);}</span>
<span id="cb1-21"><a href="#cb1-21"></a>node <span class="kw">operator</span> -(<span class="at">const</span> node &amp;a,<span class="at">const</span> node &amp;b){<span class="cf">return</span> node (a.x-b.x,a.y-b.y);}</span>
<span id="cb1-22"><a href="#cb1-22"></a>node <span class="kw">operator</span> *(<span class="at">const</span> node &amp;a,<span class="at">const</span> node &amp;b){<span class="cf">return</span> node (a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}</span>
<span id="cb1-23"><a href="#cb1-23"></a></span>
<span id="cb1-24"><a href="#cb1-24"></a><span class="dt">void</span> init(<span class="dt">int</span> n){</span>
<span id="cb1-25"><a href="#cb1-25"></a>    rep(i,n){</span>
<span id="cb1-26"><a href="#cb1-26"></a>        omega[i]=node(cos(<span class="fl">2.0</span>*pi*i/n),sin(<span class="fl">2.0</span>*pi*i/n));</span>
<span id="cb1-27"><a href="#cb1-27"></a>        a_omega[i]=node(cos(<span class="fl">2.0</span>*pi*i/n),-sin(<span class="fl">2.0</span>*pi*i/n));</span>
<span id="cb1-28"><a href="#cb1-28"></a>    }</span>
<span id="cb1-29"><a href="#cb1-29"></a>}</span>
<span id="cb1-30"><a href="#cb1-30"></a></span>
<span id="cb1-31"><a href="#cb1-31"></a><span class="dt">void</span> FFT(<span class="dt">int</span> n,node *a,node *w){</span>
<span id="cb1-32"><a href="#cb1-32"></a>    <span class="dt">int</span> i,j=<span class="dv">0</span>,k;</span>
<span id="cb1-33"><a href="#cb1-33"></a>    rep(i,n){</span>
<span id="cb1-34"><a href="#cb1-34"></a>        <span class="cf">if</span> (i&gt;j) swap(a[i],a[j]);</span>
<span id="cb1-35"><a href="#cb1-35"></a>        <span class="cf">for</span> (<span class="dt">int</span> l=n&gt;&gt;<span class="dv">1</span>;(j^=l)&lt;l;l&gt;&gt;=<span class="dv">1</span>);</span>
<span id="cb1-36"><a href="#cb1-36"></a>    }</span>
<span id="cb1-37"><a href="#cb1-37"></a>    <span class="cf">for</span> (i=<span class="dv">2</span>;i&lt;=n;i&lt;&lt;=<span class="dv">1</span>){</span>
<span id="cb1-38"><a href="#cb1-38"></a>        <span class="dt">int</span> m=i&gt;&gt;<span class="dv">1</span>;</span>
<span id="cb1-39"><a href="#cb1-39"></a>        <span class="cf">for</span> (j=<span class="dv">0</span>;j&lt;n;j+=i)</span>
<span id="cb1-40"><a href="#cb1-40"></a>            rep(k,m){</span>
<span id="cb1-41"><a href="#cb1-41"></a>                node z=a[j+k+m]*w[n/i*k];</span>
<span id="cb1-42"><a href="#cb1-42"></a>                a[j+k+m]=a[j+k]-z;</span>
<span id="cb1-43"><a href="#cb1-43"></a>                a[j+k]=a[j+k]+z;</span>
<span id="cb1-44"><a href="#cb1-44"></a>            }</span>
<span id="cb1-45"><a href="#cb1-45"></a>    }</span>
<span id="cb1-46"><a href="#cb1-46"></a>}</span>
<span id="cb1-47"><a href="#cb1-47"></a></span>
<span id="cb1-48"><a href="#cb1-48"></a><span class="dt">int</span> main(){</span>
<span id="cb1-49"><a href="#cb1-49"></a>    <span class="co">//輸入</span></span>
<span id="cb1-50"><a href="#cb1-50"></a>    cin&gt;&gt;c;n=c.size()-<span class="dv">1</span>;</span>
<span id="cb1-51"><a href="#cb1-51"></a>    rep(i,SZ(c)) a[n-i].x=(<span class="dt">double</span>)(c[i]-<span class="ch">&#39;0&#39;</span>);</span>
<span id="cb1-52"><a href="#cb1-52"></a>    cin&gt;&gt;c;m=c.size()-<span class="dv">1</span>;</span>
<span id="cb1-53"><a href="#cb1-53"></a>    rep(i,SZ(c)) b[m-i].x=(<span class="dt">double</span>)(c[i]-<span class="ch">&#39;0&#39;</span>);</span>
<span id="cb1-54"><a href="#cb1-54"></a></span>
<span id="cb1-55"><a href="#cb1-55"></a>    <span class="co">//計算最高位</span></span>
<span id="cb1-56"><a href="#cb1-56"></a>    fn=<span class="dv">1</span>;</span>
<span id="cb1-57"><a href="#cb1-57"></a>    <span class="cf">while</span> (fn&lt;=m+n) </span>
<span id="cb1-58"><a href="#cb1-58"></a>        fn&lt;&lt;=<span class="dv">1</span>;</span>
<span id="cb1-59"><a href="#cb1-59"></a>    init(fn);</span>
<span id="cb1-60"><a href="#cb1-60"></a></span>
<span id="cb1-61"><a href="#cb1-61"></a>    <span class="co">//頻域-&gt;時域 </span></span>
<span id="cb1-62"><a href="#cb1-62"></a>        FFT(fn,a,omega);</span>
<span id="cb1-63"><a href="#cb1-63"></a>        FFT(fn,b,omega);</span>
<span id="cb1-64"><a href="#cb1-64"></a></span>
<span id="cb1-65"><a href="#cb1-65"></a>    <span class="co">//時域-&gt;時域     </span></span>
<span id="cb1-66"><a href="#cb1-66"></a>    rep(i,fn+<span class="dv">1</span>)</span>
<span id="cb1-67"><a href="#cb1-67"></a>        a[i]=a[i]*b[i];</span>
<span id="cb1-68"><a href="#cb1-68"></a></span>
<span id="cb1-69"><a href="#cb1-69"></a>    <span class="co">//時域-&gt;頻域 </span></span>
<span id="cb1-70"><a href="#cb1-70"></a>    FFT(fn,a,a_omega);</span>
<span id="cb1-71"><a href="#cb1-71"></a>    rep(i,fn+<span class="dv">1</span>)</span>
<span id="cb1-72"><a href="#cb1-72"></a>        num[i]=(<span class="dt">int</span>)(a[i].x/fn+<span class="fl">0.5</span>);</span>
<span id="cb1-73"><a href="#cb1-73"></a></span>
<span id="cb1-74"><a href="#cb1-74"></a>    <span class="co">//進位</span></span>
<span id="cb1-75"><a href="#cb1-75"></a>    rep(i,fn+<span class="dv">1</span>){</span>
<span id="cb1-76"><a href="#cb1-76"></a>        num[i+<span class="dv">1</span>]+=num[i]/<span class="dv">10</span>;</span>
<span id="cb1-77"><a href="#cb1-77"></a>        num[i]%=<span class="dv">10</span>;</span>
<span id="cb1-78"><a href="#cb1-78"></a>    }</span>
<span id="cb1-79"><a href="#cb1-79"></a></span>
<span id="cb1-80"><a href="#cb1-80"></a>    <span class="co">//輸出</span></span>
<span id="cb1-81"><a href="#cb1-81"></a>    <span class="dt">int</span> len=m+n+<span class="dv">1</span>;</span>
<span id="cb1-82"><a href="#cb1-82"></a>    <span class="cf">while</span>(num[len]==<span class="dv">0</span>) len--;</span>
<span id="cb1-83"><a href="#cb1-83"></a>    <span class="cf">for</span> (<span class="dt">int</span> i=len;i&gt;=<span class="dv">0</span>;i--) cout&lt;&lt;num[i];</span>
<span id="cb1-84"><a href="#cb1-84"></a>    cout&lt;&lt;endl&lt;&lt;len&lt;&lt;endl;</span>
<span id="cb1-85"><a href="#cb1-85"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb1-86"><a href="#cb1-86"></a>}</span></code></pre></div>
</section>
    </div>
  </div>

  <script src="./reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,

        // Optional reveal.js plugins
        dependencies: [
          { src: './reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: './reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: './reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
